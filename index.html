<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mautasim Royal Carrom Pro - Tournament Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; align-items: center; justify-content: center; height: 100vh; overflow: hidden; font-family: 'Arial', sans-serif; }
        #game-wrapper { position: relative; border: 20px solid #3e2723; border-radius: 8px; box-shadow: 0 0 50px #000; }
        #ui { position: absolute; top: -60px; width: 100%; display: flex; justify-content: space-around; color: #fff; pointer-events: none; }
        .p-box { padding: 5px 15px; background: #333; border-radius: 4px; border-bottom: 4px solid #555; transition: 0.3s; }
        .active { border-bottom-color: #d32f2f; transform: translateY(-3px); background: #444; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="ui">
        <div id="p1-ui" class="p-box active">P1: 0</div>
        <div id="p2-ui" class="p-box">P2: 0</div>
        <div id="p3-ui" class="p-box">P3: 0</div>
        <div id="p4-ui" class="p-box">P4: 0</div>
    </div>
</div>

<script>
const GAME_SIZE = 740; // Regulation 74cm scale
const CENTER = GAME_SIZE / 2;
const STOP_THRESHOLD = 8; // Fix for "striker isn't stopped"

const config = {
    type: Phaser.AUTO,
    parent: 'game-wrapper',
    width: GAME_SIZE,
    height: GAME_SIZE,
    backgroundColor: '#f3e5ab', // Birch Plywood
    physics: { default: 'arcade', arcade: { friction: 0.05, debug: false } },
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);
let striker, coins, pockets, graphics, isAiming = false, startPos = {}, currentPlayer = 1;
let scores = { 1: 0, 2: 0, 3: 0, 4: 0 }, waitingForStop = false;

function preload() {}

function create() {
    let boardG = this.add.graphics();
    
    // --- BOARD MARKINGS ---
    boardG.lineStyle(2, 0x3e2723, 0.5);
    // Outer Circle & Queen Circle
    boardG.strokeCircle(CENTER, CENTER, 105).strokeCircle(CENTER, CENTER, 22);
    
    // Pockets
    boardG.fillStyle(0x111111).fillCircle(0, 0, 51).fillCircle(GAME_SIZE, 0, 51).fillCircle(0, GAME_SIZE, 51).fillCircle(GAME_SIZE, GAME_SIZE, 51);

    // Baseline & Foul Lines
    const drawSide = (angle) => {
        let container = this.add.container(CENTER, CENTER);
        let g = this.add.graphics();
        container.add(g);
        g.lineStyle(2, 0x3e2723, 0.8);
        g.strokeLineShape(new Phaser.Geom.Line(-210, 225, 210, 225)); // Inner
        g.strokeLineShape(new Phaser.Geom.Line(-210, 260, 210, 260)); // Outer
        g.fillStyle(0xd32f2f).fillCircle(-210, 242, 14).fillCircle(210, 242, 14); // Base Circles
        container.setAngle(angle);
    };
    [0, 90, 180, 270].forEach(a => drawSide(a));

    // --- PIECES ---
    let tex = this.make.graphics();
    tex.fillStyle(0xe0e0e0).fillCircle(22,22,22).lineStyle(3,0xd32f2f).strokeCircle(22,22,20).generateTexture('striker',44,44);
    tex.clear().fillStyle(0xffffff).fillCircle(15,15,15).lineStyle(2,0x8d6e63).strokeCircle(15,15,14).generateTexture('white',30,30);
    tex.clear().fillStyle(0x333333).fillCircle(15,15,15).lineStyle(1,0x000000).strokeCircle(15,15,14).generateTexture('black',30,30);
    tex.clear().fillStyle(0xd32f2f).fillCircle(15,15,15).lineStyle(2,0xffffff).strokeCircle(15,15,14).generateTexture('queen',30,30);

    pockets = this.physics.add.staticGroup();
    [[0,0],[GAME_SIZE,0],[0,GAME_SIZE],[GAME_SIZE,GAME_SIZE]].forEach(p => pockets.create(p[0],p[1],null).setSize(60,60).setVisible(false));

    coins = this.physics.add.group({ bounceX: 0.6, bounceY: 0.6, dragX: 0.985, dragY: 0.985, useDamping: true });
    
    // Standard Formation
    createCoin(this, CENTER, CENTER, 'queen');
    for(let i=0; i<6; i++){
        let a = i*(Math.PI/3);
        createCoin(this, CENTER+Math.cos(a)*32, CENTER+Math.sin(a)*32, 'white');
        createCoin(this, CENTER+Math.cos(a+0.5)*64, CENTER+Math.sin(a+0.5)*64, 'black');
    }

    striker = this.physics.add.image(CENTER, 597, 'striker').setCircle(22).setCollideWorldBounds(true).setDamping(true).setDrag(0.97).setBounce(0.5);
    
    this.physics.add.collider(striker, coins);
    this.physics.add.collider(coins, coins);
    
    this.physics.add.overlap(coins, pockets, (c) => { 
        scores[currentPlayer] += (c.texture.key === 'queen') ? 50 : 20;
        updateScoreboard();
        c.destroy(); 
    });
    
    this.physics.add.overlap(striker, pockets, () => { 
        scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 10); // Foul penalty
        updateScoreboard();
        striker.setPosition(-100, -100).setVelocity(0); 
    });

    graphics = this.add.graphics();

    // --- TWO FINGER LOGIC ---
    this.input.on('pointerdown', (p) => {
        if(waitingForStop) return;
        
        // If touching near striker, start aiming (2nd finger feel)
        if(Phaser.Math.Distance.Between(p.x, p.y, striker.x, striker.y) < 60) {
            isAiming = true;
            startPos = {x: p.x, y: p.y};
        }
    });

    this.input.on('pointermove', (p) => {
        if(waitingForStop) return;
        
        if(!isAiming && p.isDown) {
            // First finger: Positioning on baseline
            moveStriker(p.x, p.y);
        } else if (isAiming) {
            // Second finger/drag: Aiming
            graphics.clear().lineStyle(2, 0x000000, 0.5);
            graphics.lineBetween(striker.x, striker.y, striker.x + (startPos.x - p.x), striker.y + (startPos.y - p.y));
        }
    });

    this.input.on('pointerup', (p) => {
        if(isAiming) {
            graphics.clear();
            let forceX = (startPos.x - p.x) * 5.5;
            let forceY = (startPos.y - p.y) * 5.5;
            striker.setVelocity(forceX, forceY);
            isAiming = false;
            waitingForStop = true;
        }
    });
}

function moveStriker(x, y) {
    // Enforce touching both baselines
    let min = 180, max = 560;
    if(currentPlayer === 1) striker.setPosition(Phaser.Math.Clamp(x, min, max), 597);
    else if(currentPlayer === 3) striker.setPosition(Phaser.Math.Clamp(x, min, max), 143);
    else if(currentPlayer === 2) striker.setPosition(143, Phaser.Math.Clamp(y, min, max));
    else if(currentPlayer === 4) striker.setPosition(597, Phaser.Math.Clamp(y, min, max));
}

function update() {
    if(waitingForStop) {
        let moving = false;
        if(striker.body.speed > STOP_THRESHOLD) moving = true;
        else striker.setVelocity(0); // Kill jitter

        coins.children.iterate(c => {
            if(c.body.speed > STOP_THRESHOLD) moving = true;
            else c.setVelocity(0);
        });

        if(!moving) {
            waitingForStop = false;
            nextPlayer();
        }
    }
}

function nextPlayer() {
    document.querySelectorAll('.p-box').forEach(b => b.classList.remove('active'));
    currentPlayer = (currentPlayer % 4) + 1;
    document.getElementById(`p${currentPlayer}-ui`).classList.add('active');
    
    striker.setVelocity(0);
    moveStriker(CENTER, CENTER); // Reset to line center
}

function updateScoreboard() {
    for(let i=1; i<=4; i++) document.getElementById(`p${i}-ui`).innerText = `P${i}: ${scores[i]}`;
}

function createCoin(s, x, y, k) { 
    s.physics.add.existing(coins.create(x, y, k).setCircle(15).setCollideWorldBounds(true).setBounce(0.5)); 
}
</script>
</body>
</html>
