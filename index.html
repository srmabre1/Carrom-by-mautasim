<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Carrom Royal: AI Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Poppins:wght@400;600&display=swap');

        :root {
            --gold: #d4af37;
            --wood: #2c1810;
            --cream: #f5deb3;
        }

        body {
            margin: 0; background: #0a0a0a; color: white;
            font-family: 'Poppins', sans-serif; display: flex;
            flex-direction: column; align-items: center; height: 100vh; overflow: hidden;
        }

        /* --- Header UI --- */
        .header {
            width: 100%; max-width: 500px; display: flex;
            justify-content: space-around; padding: 20px 0; z-index: 10;
        }
        .stat-card {
            background: linear-gradient(145deg, #1a1a1a, #000);
            border: 1px solid var(--gold); padding: 10px 20px;
            border-radius: 12px; text-align: center; min-width: 100px;
            transition: 0.3s;
        }
        .stat-card.active { box-shadow: 0 0 20px var(--gold); transform: scale(1.1); }
        .score { font-family: 'Cinzel', serif; font-size: 24px; color: var(--gold); }
        .player-label { font-size: 10px; letter-spacing: 2px; color: #aaa; }

        /* --- Game Board --- */
        #game-container { position: relative; cursor: crosshair; }
        canvas {
            border: 10px solid var(--wood); border-radius: 25px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }

        /* --- Controls --- */
        .controls {
            width: 100%; max-width: 450px; margin-top: 20px;
            display: flex; flex-direction: column; align-items: center; gap: 15px;
        }
        .slider-box {
            width: 90%; background: #1a1a1a; padding: 15px;
            border-radius: 50px; border: 1px solid #333; display: flex; align-items: center;
        }
        input[type=range] { flex: 1; accent-color: var(--gold); cursor: pointer; }
        
        #overlay-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif; font-size: 40px; color: var(--gold);
            pointer-events: none; opacity: 0; transition: 0.5s; text-align: center;
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="stat-card active" id="p1-ui">
            <div class="player-label">YOU</div>
            <div class="score" id="s1">0</div>
        </div>
        <div class="stat-card" id="p2-ui">
            <div class="player-label">CPU (BLACK)</div>
            <div class="score" id="s2">0</div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="canvas"></canvas>
        <div id="overlay-msg">YOUR TURN</div>
    </div>

    <div class="controls">
        <div class="slider-box">
            <span style="margin-right:15px">POSITION</span>
            <input type="range" id="striker-slider" min="-140" max="140" value="0">
        </div>
        <div style="font-size: 12px; color: #666;">DRAG STRIKER BACK TO AIM & SHOOT</div>
    </div>

<script>
    const { Engine, Render, World, Bodies, Body, Vector, Events } = Matter;

    // --- CONFIG & STATE ---
    const WIDTH = 600;
    const engine = Engine.create();
    engine.world.gravity.y = 0;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const size = Math.min(window.innerWidth - 30, 500);
    canvas.width = WIDTH; canvas.height = WIDTH;
    canvas.style.width = size + "px"; canvas.style.height = size + "px";

    let state = {
        turn: 'white', 
        phase: 'AIMING', // AIMING, MOVING, AI
        scores: { white: 0, black: 0 },
        strikerLineY: 485,
        pieces: [],
        striker: null,
        drag: { start: null, current: null }
    };

    // --- INITIALIZATION ---
    function init() {
        World.clear(engine.world);
        state.pieces = [];
        
        // Walls
        const wallProp = { isStatic: true, restitution: 0.6, friction: 0.05 };
        World.add(engine.world, [
            Bodies.rectangle(300, 10, 600, 20, wallProp), // T
            Bodies.rectangle(300, 590, 600, 20, wallProp), // B
            Bodies.rectangle(10, 300, 20, 600, wallProp), // L
            Bodies.rectangle(590, 300, 20, 600, wallProp)  // R
        ]);

        spawnCoins();
        spawnStriker();
        loop();
    }

    function spawnCoins() {
        const cx = 300, cy = 300, r = 15;
        const addC = (x, y, type) => {
            const p = Bodies.circle(x, y, r, { restitution: 0.8, frictionAir: 0.018, label: type });
            state.pieces.push(p);
            World.add(engine.world, p);
        };

        addC(cx, cy, 'queen');
        for(let i=0; i<6; i++) {
            let a = i * Math.PI/3;
            addC(cx + Math.cos(a)*31, cy + Math.sin(a)*31, i%2==0?'white':'black');
        }
        for(let i=0; i<12; i++) {
            let a = i * Math.PI/6;
            addC(cx + Math.cos(a)*62, cy + Math.sin(a)*62, [0,3,4,7,8,11].includes(i)?'white':'black');
        }
    }

    function spawnStriker() {
        if(state.striker) World.remove(engine.world, state.striker);
        const y = state.turn === 'white' ? 485 : 115;
        state.striker = Bodies.circle(300, y, 24, { restitution: 0.5, frictionAir: 0.02, mass: 5, label: 'striker' });
        World.add(engine.world, state.striker);
        document.getElementById('striker-slider').value = 0;
        document.getElementById('striker-slider').disabled = (state.turn === 'black');
    }

    // --- AI LOGIC (The "Beat the Video" Feature) ---
    function runAI() {
        if(state.turn !== 'black') return;
        
        setTimeout(() => {
            // Find a black piece to hit
            const targets = state.pieces.filter(p => p.label === 'black');
            const target = targets[Math.floor(Math.random() * targets.length)] || state.pieces[0];
            
            // Slide striker to a random position on its line
            const targetX = 300 + (Math.random() * 200 - 100);
            Body.setPosition(state.striker, { x: targetX, y: 115 });

            // Aim at target
            setTimeout(() => {
                const vec = Vector.sub(target.position, state.striker.position);
                const force = Vector.mult(Vector.normalise(vec), 0.25);
                Body.applyForce(state.striker, state.striker.position, force);
                state.phase = 'MOVING';
            }, 800);
        }, 1000);
    }

    // --- CORE LOOP ---
    function loop() {
        Engine.update(engine, 1000/60);
        
        // Pocket Detection
        const pockets = [{x:35,y:35}, {x:565,y:35}, {x:35,y:565}, {x:565,y:565}];
        state.pieces.forEach((p, idx) => {
            pockets.forEach(pk => {
                if(Vector.magnitude(Vector.sub(p.position, pk)) < 38) {
                    handleScore(p.label);
                    World.remove(engine.world, p);
                    state.pieces.splice(idx, 1);
                }
            });
        });

        // Check if striker pocketed (Foul)
        pockets.forEach(pk => {
            if(Vector.magnitude(Vector.sub(state.striker.position, pk)) < 38) {
                handleScore('foul');
                Body.setPosition(state.striker, {x:-100, y:-100});
            }
        });

        // Switch turns when stopped
        if(state.phase === 'MOVING') {
            const moving = engine.world.bodies.some(b => b.speed > 0.2);
            if(!moving) {
                state.turn = (state.turn === 'white') ? 'black' : 'white';
                state.phase = 'AIMING';
                updateUI();
                spawnStriker();
                if(state.turn === 'black') {
                    state.phase = 'AI';
                    runAI();
                }
            }
        }

        draw();
        requestAnimationFrame(loop);
    }

    function handleScore(type) {
        if(type === 'white') state.scores.white += 10;
        if(type === 'black') state.scores.black += 10;
        if(type === 'queen') state.scores[state.turn] += 50;
        if(type === 'foul') state.scores[state.turn] -= 5;
        notify(type.toUpperCase());
    }

    // --- DRAWING ---
    function draw() {
        ctx.clearRect(0,0,WIDTH,WIDTH);
        
        // 1. Board
        ctx.fillStyle = '#1a0f0a'; ctx.fillRect(0,0,WIDTH,WIDTH);
        ctx.fillStyle = '#f5deb3'; ctx.fillRect(20,20,560,560);
        
        // Design
        ctx.strokeStyle = '#2c1810'; ctx.lineWidth = 2;
        ctx.strokeRect(30,30,540,540);
        ctx.beginPath(); ctx.arc(300,300,80,0,7); ctx.stroke();
        
        // Pockets
        ctx.fillStyle = '#000';
        [{x:35,y:35},{x:565,y:35},{x:35,y:565},{x:565,y:565}].forEach(p => {
            ctx.beginPath(); ctx.arc(p.x,p.y,35,0,7); ctx.fill();
        });

        // Striker Lines
        ctx.strokeStyle = '#d32f2f';
        ctx.strokeRect(100, 475, 400, 20);
        ctx.strokeRect(100, 105, 400, 20);

        // 2. Bodies
        state.pieces.forEach(p => drawCircle(p.position, 15, p.label));
        drawCircle(state.striker.position, 24, 'striker');

        // 3. Aim Line
        if(state.drag.start && state.drag.current) {
            ctx.beginPath();
            ctx.moveTo(state.striker.position.x, state.striker.position.y);
            ctx.lineTo(state.drag.current.x, state.drag.current.y);
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
            ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        }
    }

    function drawCircle(pos, r, type) {
        ctx.save();
        ctx.translate(pos.x, pos.y);
        
        let grad = ctx.createRadialGradient(-r/3, -r/3, 0, 0, 0, r);
        if(type === 'white') { grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#ccc'); }
        else if(type === 'black') { grad.addColorStop(0, '#444'); grad.addColorStop(1, '#000'); }
        else if(type === 'queen') { grad.addColorStop(0, '#ff69b4'); grad.addColorStop(1, '#c71585'); }
        else { grad.addColorStop(0, '#ffd700'); grad.addColorStop(1, '#b8860b'); }

        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(0,0,r,0,7); ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
        
        // Shine
        ctx.beginPath(); ctx.arc(-r/3, -r/3, r/4, 0, 7);
        ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fill();
        ctx.restore();
    }

    // --- INPUTS ---
    document.getElementById('striker-slider').oninput = (e) => {
        if(state.phase === 'AIMING') {
            Body.setPosition(state.striker, { x: 300 + parseInt(e.target.value), y: state.strikerLineY });
        }
    };

    canvas.onmousedown = (e) => {
        if(state.phase !== 'AIMING') return;
        const rect = canvas.getBoundingClientRect();
        const pos = { x: (e.clientX - rect.left)*(600/size), y: (e.clientY - rect.top)*(600/size) };
        if(Vector.magnitude(Vector.sub(pos, state.striker.position)) < 40) state.drag.start = pos;
    };

    window.onmousemove = (e) => {
        if(state.drag.start) {
            const rect = canvas.getBoundingClientRect();
            state.drag.current = { x: (e.clientX - rect.left)*(600/size), y: (e.clientY - rect.top)*(600/size) };
        }
    };

    window.onmouseup = () => {
        if(state.drag.start && state.drag.current) {
            const dist = Vector.sub(state.drag.start, state.drag.current);
            const force = Vector.mult(dist, 0.18);
            Body.applyForce(state.striker, state.striker.position, force);
            state.phase = 'MOVING';
        }
        state.drag.start = null; state.drag.current = null;
    };

    // --- UI HELPERS ---
    function updateUI() {
        document.getElementById('s1').innerText = state.scores.white;
        document.getElementById('s2').innerText = state.scores.black;
        document.getElementById('p1-ui').className = state.turn === 'white' ? 'stat-card active' : 'stat-card';
        document.getElementById('p2-ui').className = state.turn === 'black' ? 'stat-card active' : 'stat-card';
        notify(state.turn === 'white' ? "YOUR TURN" : "CPU THINKING...");
    }

    function notify(msg) {
        const el = document.getElementById('overlay-msg');
        el.innerText = msg; el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 1500);
    }

    init();
</script>
</body>
</html>
