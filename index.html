<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ATLETO Carrom Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@500;700&display=swap');
        
        body { margin: 0; background: #1a1a1a; color: white; font-family: 'Oswald', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; touch-action: none; }
        
        /* ATLETO Realistic HUD */
        .hud { width: 100%; max-width: 500px; display: flex; justify-content: space-between; padding: 10px; position: absolute; top: 10px; }
        .p-card { background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 8px; border: 2px solid #444; min-width: 100px; text-align: center; }
        .p-card.active { border-color: #e74c3c; box-shadow: 0 0 15px rgba(231, 76, 60, 0.4); }
        .score { font-size: 28px; color: #f1c40f; }
        .label { font-size: 12px; color: #aaa; letter-spacing: 1px; }

        #board-container { position: relative; border: 15px solid #5d4037; border-radius: 20px; box-shadow: 0 20px 50px rgba(0,0,0,0.9); }
        canvas { background: #fdf5e6; border-radius: 5px; }

        .ui-bottom { width: 100%; max-width: 450px; position: absolute; bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        input[type=range] { width: 80%; accent-color: #e74c3c; cursor: pointer; }
        
        #msg-overlay { position: absolute; font-size: 48px; font-weight: 700; text-transform: uppercase; color: white; text-shadow: 2px 2px 10px black; opacity: 0; pointer-events: none; transition: 0.3s; z-index: 100; }
    </style>
</head>
<body>

    <div id="msg-overlay">STRIKE!</div>

    <div class="hud">
        <div class="p-card active" id="p1-ui">
            <div class="label">PLAYER 1</div>
            <div id="s1" class="score">0</div>
        </div>
        <div class="p-card" id="p2-ui">
            <div class="label">GRANDMASTER AI</div>
            <div id="s2" class="score">0</div>
        </div>
    </div>

    <div id="board-container">
        <canvas id="carrom"></canvas>
    </div>

    <div class="ui-bottom">
        <input type="range" id="positioner" min="-140" max="140" value="0">
        <div style="font-size: 11px; color: #888;">USE SLIDER TO MOVE â€¢ DRAG STRIKER TO AIM</div>
    </div>

<script>
const { Engine, World, Bodies, Body, Vector, Events } = Matter;

// --- CONFIGURATION ---
const WIDTH = 600;
const engine = Engine.create();
engine.world.gravity.y = 0;
const canvas = document.getElementById('carrom');
const ctx = canvas.getContext('2d');
const scale = Math.min(window.innerWidth - 40, 500) / WIDTH;
canvas.width = WIDTH; canvas.height = WIDTH;
canvas.style.width = (WIDTH * scale) + "px";
canvas.style.height = (WIDTH * scale) + "px";

let gameState = {
    turn: 'white',
    phase: 'AIMING',
    scores: { white: 0, black: 0 },
    striker: null,
    pieces: [],
    drag: { start: null, current: null },
    lastPocketed: false
};

// --- INITIALIZE BOARD ---
function initBoard() {
    World.clear(engine.world);
    gameState.pieces = [];
    
    // Borders
    const wallAttr = { isStatic: true, restitution: 0.7, friction: 0.02 };
    World.add(engine.world, [
        Bodies.rectangle(300, 10, 600, 20, wallAttr),
        Bodies.rectangle(300, 590, 600, 20, wallAttr),
        Bodies.rectangle(10, 300, 20, 600, wallAttr),
        Bodies.rectangle(590, 300, 20, 600, wallAttr)
    ]);

    // Coins Setup
    const addP = (x, y, type) => {
        const p = Bodies.circle(x, y, 14, { restitution: 0.8, frictionAir: 0.018, label: type });
        gameState.pieces.push(p);
        World.add(engine.world, p);
    };

    const cx = 300, cy = 300;
    addP(cx, cy, 'queen');
    for(let i=0; i<6; i++) {
        let a = i * Math.PI/3;
        addP(cx + Math.cos(a)*29, cy + Math.sin(a)*29, i%2==0?'white':'black');
    }
    for(let i=0; i<12; i++) {
        let a = i * Math.PI/6;
        addP(cx + Math.cos(a)*58, cy + Math.sin(a)*58, [0,3,4,7,8,11].includes(i)?'white':'black');
    }
    resetStriker();
}

function resetStriker() {
    if(gameState.striker) World.remove(engine.world, gameState.striker);
    const yPos = gameState.turn === 'white' ? 485 : 115;
    gameState.striker = Bodies.circle(300, yPos, 22, { 
        restitution: 0.4, frictionAir: 0.02, mass: 6, label: 'striker' 
    });
    World.add(engine.world, gameState.striker);
    document.getElementById('positioner').value = 0;
    document.getElementById('positioner').disabled = (gameState.turn === 'black');
}

// --- SMART AI LOGIC ---
function runAI() {
    if(gameState.turn !== 'black') return;
    setTimeout(() => {
        const targets = gameState.pieces.filter(p => p.label === 'black');
        if(targets.length === 0) return;
        
        const target = targets[Math.floor(Math.random()*targets.length)];
        const slideX = target.position.x + (Math.random()*40-20);
        Body.setPosition(gameState.striker, { x: Math.max(160, Math.min(440, slideX)), y: 115 });

        setTimeout(() => {
            const vec = Vector.sub(target.position, gameState.striker.position);
            const force = Vector.mult(Vector.normalise(vec), 0.3);
            Body.applyForce(gameState.striker, gameState.striker.position, force);
            gameState.phase = 'MOVING';
        }, 1000);
    }, 1200);
}

// --- GAME LOGIC ---
Events.on(engine, 'afterUpdate', () => {
    const pockets = [{x:35,y:35}, {x:565,y:35}, {x:35,y:565}, {x:565,y:565}];
    
    // Coin Pocketing
    gameState.pieces.forEach((p, i) => {
        pockets.forEach(pk => {
            if(Vector.magnitude(Vector.sub(p.position, pk)) < 35) {
                const points = (p.label === 'queen' ? 50 : 10);
                gameState.scores[gameState.turn] += points;
                showToast(`+${points} POCKETED!`);
                World.remove(engine.world, p);
                gameState.pieces.splice(i, 1);
                gameState.lastPocketed = true;
            }
        });
    });

    // Striker Foul
    pockets.forEach(pk => {
        if(Vector.magnitude(Vector.sub(gameState.striker.position, pk)) < 35) {
            gameState.scores[gameState.turn] -= 10;
            showToast("FOUL -10!");
            Body.setPosition(gameState.striker, {x:-500, y:-500});
        }
    });

    // Turn Management
    if(gameState.phase === 'MOVING') {
        const moving = engine.world.bodies.some(b => b.speed > 0.15);
        if(!moving) {
            if(!gameState.lastPocketed) gameState.turn = (gameState.turn === 'white' ? 'black' : 'white');
            gameState.lastPocketed = false;
            gameState.phase = 'AIMING';
            updateUI();
            resetStriker();
            if(gameState.turn === 'black') runAI();
        }
    }
});

// --- ARTISTIC RENDERER ---
function draw() {
    ctx.clearRect(0,0,WIDTH,WIDTH);
    
    // ATLETO Theme Board
    ctx.fillStyle = "#f5deb3"; ctx.fillRect(0,0,WIDTH,WIDTH);
    ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 2;
    ctx.strokeRect(35,35,530,530);
    
    // Corner Lines & Circles
    ctx.beginPath(); ctx.arc(300,300,70,0,7); ctx.stroke();
    ctx.fillStyle = "#000"; pockets().forEach(p => {
        ctx.beginPath(); ctx.arc(p.x, p.y, 35, 0, 7); ctx.fill();
    });

    // Baseline Striker Zones
    ctx.strokeStyle = "#c0392b";
    ctx.strokeRect(150, 475, 300, 20); // Bottom
    ctx.strokeRect(150, 105, 300, 20); // Top

    // Render Coins
    gameState.pieces.forEach(p => renderCoin(p));
    renderCoin(gameState.striker);

    // Aiming Dotted Line
    if(gameState.drag.start && gameState.drag.current) {
        ctx.beginPath();
        ctx.moveTo(gameState.striker.position.x, gameState.striker.position.y);
        ctx.lineTo(gameState.drag.current.x, gameState.drag.current.y);
        ctx.setLineDash([5,5]); ctx.strokeStyle = "rgba(0,0,0,0.4)"; ctx.stroke(); ctx.setLineDash([]);
    }

    requestAnimationFrame(draw);
}

function renderCoin(b) {
    if(!b) return;
    const {x, y} = b.position;
    const r = b.circleRadius;
    const type = b.label;

    ctx.save();
    ctx.translate(x, y);
    
    // Shadow
    ctx.beginPath(); ctx.arc(2, 2, r, 0, 7); ctx.fillStyle = "rgba(0,0,0,0.2)"; ctx.fill();

    // Body
    let grad = ctx.createRadialGradient(-r/3, -r/3, 0, 0, 0, r);
    if(type === 'striker') { grad.addColorStop(0, '#e74c3c'); grad.addColorStop(1, '#962d22'); }
    else if(type === 'queen') { grad.addColorStop(0, '#f39c12'); grad.addColorStop(1, '#d35400'); }
    else if(type === 'white') { grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#bdc3c7'); }
    else { grad.addColorStop(0, '#444'); grad.addColorStop(1, '#111'); }

    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0, 0, r, 0, 7); ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.4)"; ctx.lineWidth = 1; ctx.stroke();
    ctx.restore();
}

function pockets() { return [{x:35,y:35},{x:565,y:35},{x:35,y:565},{x:565,y:565}]; }

// --- INPUTS ---
const positioner = document.getElementById('positioner');
positioner.oninput = () => {
    if(gameState.phase === 'AIMING') {
        const y = gameState.turn === 'white' ? 485 : 115;
        Body.setPosition(gameState.striker, { x: 300 + parseInt(positioner.value), y: y });
    }
};

canvas.onmousedown = (e) => {
    if(gameState.phase !== 'AIMING' || gameState.turn === 'black') return;
    const rect = canvas.getBoundingClientRect();
    const pos = { x: (e.clientX - rect.left)/scale, y: (e.clientY - rect.top)/scale };
    if(Vector.magnitude(Vector.sub(pos, gameState.striker.position)) < 50) gameState.drag.start = pos;
};

window.onmousemove = (e) => {
    if(!gameState.drag.start) return;
    const rect = canvas.getBoundingClientRect();
    gameState.drag.current = { x: (e.clientX - rect.left)/scale, y: (e.clientY - rect.top)/scale };
};

window.onmouseup = () => {
    if(gameState.drag.start && gameState.drag.current) {
        const force = Vector.mult(Vector.sub(gameState.drag.start, gameState.drag.current), 0.2);
        Body.applyForce(gameState.striker, gameState.striker.position, force);
        gameState.phase = 'MOVING';
    }
    gameState.drag.start = null; gameState.drag.current = null;
};

// --- UTILS ---
function updateUI() {
    document.getElementById('s1').innerText = gameState.scores.white;
    document.getElementById('s2').innerText = gameState.scores.black;
    document.getElementById('p1-ui').className = gameState.turn === 'white' ? 'p-card active' : 'p-card';
    document.getElementById('p2-ui').className = gameState.turn === 'black' ? 'p-card active' : 'p-card';
}

function showToast(txt) {
    const el = document.getElementById('msg-overlay');
    el.innerText = txt; el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 1000);
}

initBoard();
updateUI();
draw();
function mainLoop() { Engine.update(engine, 1000/60); requestAnimationFrame(mainLoop); }
mainLoop();
</script>
</body>
</html>
