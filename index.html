<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mautasim Royal Carrom Pro - Tournament Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; background: #1a1a1a; display: flex; align-items: center; justify-content: center; height: 100vh; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-wrapper { position: relative; border: 25px solid #3e2723; border-radius: 8px; box-shadow: 0 0 100px rgba(0,0,0,0.7); }
        #ui { position: absolute; top: -65px; width: 100%; display: flex; justify-content: space-between; color: #fff; }
        .p-box { padding: 5px 15px; border-radius: 4px; background: #333; border-bottom: 3px solid #555; font-weight: bold; min-width: 100px; text-align: center; }
        .active { border-bottom-color: #d32f2f; background: #444; transform: translateY(-5px); box-shadow: 0 5px 15px rgba(211,47,47,0.4); }
        #win-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: #FFD700; text-align: center; }
        #restart-btn { margin-top: 20px; padding: 15px 40px; background: #d32f2f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1.2rem; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="ui">
        <div id="p1-ui" class="p-box active">P1: 0</div>
        <div id="p2-ui" class="p-box">P2: 0</div>
        <div id="p3-ui" class="p-box">P3: 0</div>
        <div id="p4-ui" class="p-box">P4: 0</div>
    </div>
    <div id="win-screen">
        <h1 id="win-title">TOURNAMENT OVER</h1>
        <h2 id="winner-name"></h2>
        <button id="restart-btn" onclick="location.reload()">REMATCH</button>
    </div>
</div>

<script>
const GAME_SIZE = 740; // Regulation 74cm scaled
const CENTER = GAME_SIZE / 2;

const config = {
    type: Phaser.AUTO,
    parent: 'game-wrapper',
    width: GAME_SIZE,
    height: GAME_SIZE,
    backgroundColor: '#f3e5ab', // Birch plywood color
    physics: { 
        default: 'arcade', 
        arcade: { 
            friction: 0.05,
            debug: false 
        } 
    },
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);
let striker, coins, pockets, graphics, isAiming = false, startPos = {}, currentPlayer = 1;
let scores = { 1: 0, 2: 0, 3: 0, 4: 0 }, waitingForStop = false;
let queenPocketedThisTurn = false, queenWaitingForCover = false;

function preload() {}

function create() {
    let boardG = this.add.graphics();
    
    // --- BOARD DESIGN (TOURNAMENT SPEC) ---
    // Frame & Pockets
    boardG.fillStyle(0x000000, 0.9).fillCircle(0, 0, 50).fillCircle(GAME_SIZE, 0, 50).fillCircle(0, GAME_SIZE, 50).fillCircle(GAME_SIZE, GAME_SIZE, 50);

    // Baselines & Base Circles (The "Red Spots")
    const drawTournamentLines = (rotation) => {
        boardG.lineStyle(2, 0x3e2723, 0.8);
        // Baselines
        boardG.strokeLineShape(new Phaser.Geom.Line(160, 580, 580, 580));
        boardG.strokeLineShape(new Phaser.Geom.Line(160, 615, 580, 615));
        // End Circles
        boardG.fillStyle(0xd32f2f, 1).fillCircle(160, 597, 14).strokeCircle(160, 597, 14);
        boardG.fillCircle(580, 597, 14).strokeCircle(580, 597, 14);
    };

    // Draw lines for 4 sides
    [0, 90, 180, 270].forEach(angle => {
        let container = this.add.container(CENTER, CENTER);
        let g = this.add.graphics();
        container.add(g);
        g.lineStyle(2, 0x3e2723, 0.8);
        g.strokeLineShape(new Phaser.Geom.Line(-210, 220, 210, 220));
        g.strokeLineShape(new Phaser.Geom.Line(-210, 255, 210, 255));
        g.fillStyle(0xd32f2f).fillCircle(-210, 237, 14).strokeCircle(-210, 237, 14);
        g.fillCircle(210, 237, 14).strokeCircle(210, 237, 14);
        container.setAngle(angle);
    });

    // Center Circles
    boardG.lineStyle(2, 0x3e2723).strokeCircle(CENTER, CENTER, 100); // Outer
    boardG.lineStyle(2, 0xd32f2f).strokeCircle(CENTER, CENTER, 22);  // Queen spot

    // Branding
    this.add.text(CENTER, CENTER + 140, 'MAUTASIM PRO', { fontFamily: 'serif', fontSize: '24px', color: '#3e2723', alpha: 0.3 }).setOrigin(0.5);

    // --- ASSETS ---
    let tex = this.make.graphics();
    // Striker (Heavier, Larger)
    tex.fillStyle(0xe0e0e0).fillCircle(22,22,22).lineStyle(3,0xd32f2f).strokeCircle(22,22,19).generateTexture('striker',44,44);
    // Pieces (Regulation size)
    tex.clear().fillStyle(0xffffff).fillCircle(15,15,15).lineStyle(2,0x8d6e63).strokeCircle(15,15,14).generateTexture('white',30,30);
    tex.clear().fillStyle(0x333333).fillCircle(15,15,15).lineStyle(1,0x000000).strokeCircle(15,15,14).generateTexture('black',30,30);
    tex.clear().fillStyle(0xd32f2f).fillCircle(15,15,15).lineStyle(2,0xffffff).strokeCircle(15,15,14).generateTexture('queen',30,30);

    pockets = this.physics.add.staticGroup();
    [[0,0],[GAME_SIZE,0],[0,GAME_SIZE],[GAME_SIZE,GAME_SIZE]].forEach(p => pockets.create(p[0],p[1],null).setSize(60,60).setVisible(false));

    coins = this.physics.add.group({ bounceX: 0.6, bounceY: 0.6, dragX: 0.985, dragY: 0.985, useDamping: true });
    
    // Initial Setup (Hexagonal)
    createCoin(this, CENTER, CENTER, 'queen');
    for(let i=0; i<6; i++){
        let a = i*(Math.PI/3);
        createCoin(this, CENTER+Math.cos(a)*32, CENTER+Math.sin(a)*32, 'white');
        createCoin(this, CENTER+Math.cos(a+0.5)*64, CENTER+Math.sin(a+0.5)*64, 'black');
    }

    striker = this.physics.add.image(CENTER, 597, 'striker').setCircle(22).setCollideWorldBounds(true).setDamping(true).setDrag(0.97).setBounce(0.5);
    striker.setMass(1.5);

    this.physics.add.collider(striker, coins);
    this.physics.add.collider(coins, coins);
    
    this.physics.add.overlap(coins, pockets, (c) => { 
        handlePocket(c);
    });
    
    this.physics.add.overlap(striker, pockets, () => { 
        handleFoul();
    });

    graphics = this.add.graphics();

    this.input.on('pointerdown', (p) => {
        if(!waitingForStop) {
            if(Math.abs(p.y - striker.y) < 50 && Math.abs(p.x - striker.x) < 100) { /* drag logic */ } 
            else { isAiming = true; startPos = {x:p.x, y:p.y}; }
        }
    });

    this.input.on('pointermove', (p) => { 
        if(isAiming) { 
            graphics.clear().lineStyle(2, 0x000000, 0.5);
            graphics.lineBetween(striker.x, striker.y, striker.x + (startPos.x - p.x), striker.y + (startPos.y - p.y)); 
        }
        if(!waitingForStop && !isAiming && this.input.activePointer.isDown) {
            moveStriker(p.x, p.y);
        }
    });

    this.input.on('pointerup', (p) => { 
        if(isAiming) { 
            graphics.clear(); 
            let forceX = (startPos.x - p.x) * 5;
            let forceY = (startPos.y - p.y) * 5;
            striker.setVelocity(forceX, forceY); 
            isAiming = false; 
            waitingForStop = true; 
        }
    });
}

function handlePocket(coin) {
    let type = coin.texture.key;
    if(type === 'queen') {
        queenPocketedThisTurn = true;
        queenWaitingForCover = true;
    } else {
        if(queenWaitingForCover) {
            scores[currentPlayer] += 50; // Queen covered!
            queenWaitingForCover = false;
        }
        scores[currentPlayer] += 20;
    }
    coin.destroy();
    updateScoreboard();
}

function handleFoul() {
    scores[currentPlayer] = Math.max(0, scores[currentPlayer] - 10);
    striker.setVelocity(0);
    striker.setPosition(-100, -100); // Remove temporarily
    updateScoreboard();
}

function moveStriker(x, y) {
    let min = 180, max = 560;
    if(currentPlayer===1) striker.setPosition(Phaser.Math.Clamp(x, min, max), 597);
    else if(currentPlayer===3) striker.setPosition(Phaser.Math.Clamp(x, min, max), 143);
    else if(currentPlayer===2) striker.setPosition(143, Phaser.Math.Clamp(y, min, max));
    else if(currentPlayer===4) striker.setPosition(597, Phaser.Math.Clamp(y, min, max));
}

function update() {
    if(waitingForStop) {
        let moving = striker.body.speed > 2;
        coins.children.iterate(c => { if(c.body.speed > 2) moving = true; });
        
        if(!moving) { 
            waitingForStop = false; 
            if(queenWaitingForCover && !queenPocketedThisTurn) {
                // Failed to cover queen, respawn it
                createCoin(this, CENTER, CENTER, 'queen');
                queenWaitingForCover = false;
            }
            queenPocketedThisTurn = false;
            nextPlayer(); 
        }
    }
}

function nextPlayer() {
    document.querySelectorAll('.p-box').forEach(b => b.classList.remove('active'));
    currentPlayer = (currentPlayer % 4) + 1;
    document.getElementById(`p${currentPlayer}-ui`).classList.add('active');
    
    striker.setVelocity(0);
    if(currentPlayer===1) striker.setPosition(CENTER, 597);
    if(currentPlayer===2) striker.setPosition(143, CENTER);
    if(currentPlayer===3) striker.setPosition(CENTER, 143);
    if(currentPlayer===4) striker.setPosition(597, CENTER);
    
    if(coins.countActive() === 0) {
        showWin();
    }
}

function updateScoreboard() {
    for(let i=1; i<=4; i++) {
        document.getElementById(`p${i}-ui`).innerText = `P${i}: ${scores[i]}`;
    }
}

function createCoin(scene, x, y, k) { 
    let c = coins.create(x, y, k);
    c.setCircle(15).setCollideWorldBounds(true).setBounce(0.5).setMass(1);
}

function showWin() {
    let winner = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
    document.getElementById('winner-name').innerText = `PLAYER ${winner} WINS WITH ${scores[winner]} POINTS!`;
    document.getElementById('win-screen').style.display = 'flex';
}
</script>
</body>
</html>
